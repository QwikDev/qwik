---
title: Backpatching | Advanced
contributors:
  - thejackshelton
updated_at: '2025-08-31T10:17:00Z'
created_at: '2025-08-31T10:17:00Z'
---

# Backpatching

Similar to the Qwikloader that executes a small script, backpatching updates nodes already streamed during SSR without waking up the Qwik runtime.

### What it is

Backpatching enables SSR-correct relationships (like `aria-*` attributes) between components whose render order you can't controlâ€”common in libraries. It patches attributes after streaming, letting components link to each other without needing to hydrate or enforce a specific order.

> This is not Out-of-Order Streaming (no data fetching, no fallbacks, no server re-ordering). It is an in-order correction mechanism for already-sent attributes. It does not delay the stream in any way.

### When to use

- **Headless/component libraries**: Consumers can place parts anywhere in the subtree, but parents still need final attributes (e.g., aria-* relationships).
- **Attribute synchronization**: You need SSR output to reflect attribute values that become known only after children run.

### Automatic backpatching

Backpatching is now **automatic** and works without requiring the `SSRBackpatch` component. Qwik automatically detects when attributes need to be patched and handles it transparently.

The `SSRBackpatch` component is still supported for backward compatibility but is no longer required. It can still be used to limit the number/placement of data scripts if needed for legacy or transition purposes.

### Example

```tsx
// Backpatching now works automatically without SSRBackpatch
<Field.Root>
  <Field.Label />
  <Field.Input />
  <Field.Description />
</Field.Root>

// The aria-describedby attribute on <Field.Input> will be automatically
// corrected even if <Field.Description> runs after the input was streamed.
```

### Legacy SSRBackpatch usage

If you still want to use `SSRBackpatch` explicitly (for example, to control when data scripts are emitted), you can:

```tsx
import { component$, SSRBackpatch, Slot } from '@qwik.dev/core';

export const FieldRoot = component$(() => {
  return (
    <div>
      <SSRBackpatch>
        <Slot />
      </SSRBackpatch>
    </div>
  );
});
```

### Limitations

- **Attributes only**: Backpatching is currently limited to updating attributes. It does not change element children/text/structure.

### How it works (high level)

During SSR, when a signal write would alter an attribute that has already been streamed, Qwik records the final value using depth-first element indexing and emits a compact script to set/remove the attribute on the corresponding node. This runs immediately on page load using TreeWalker-based element traversal and does not wake the Qwik runtime.

