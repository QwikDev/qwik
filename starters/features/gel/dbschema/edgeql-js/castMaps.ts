// GENERATED by @gel/generate v0.6.4

import * as gel from "gel";
import type * as $ from "./reflection";
import * as literal from "./literal";
import type * as _std from "./modules/std";
import type * as _sys from "./modules/sys";
import type * as _stdpg from "./modules/std/pg";
import type * as _stdnethttp from "./modules/std/net/http";
import type * as _stdnet from "./modules/std/net";
import type * as _stdfts from "./modules/std/fts";
import type * as _stdenc from "./modules/std/enc";
import type * as _stdcal from "./modules/std/cal";
import type * as _schema from "./modules/schema";
import type * as _cfg from "./modules/cfg";
export interface ScalarAssignableByMap {
  "std::number": _std.$number;
  "sys::VersionStage": _sys.$VersionStage;
  "sys::TransactionIsolation": _sys.$TransactionIsolation;
  "sys::TransactionDeferrability": _sys.$TransactionDeferrability;
  "sys::TransactionAccessMode": _sys.$TransactionAccessMode;
  "sys::QueryType": _sys.$QueryType;
  "sys::OutputFormat": _sys.$OutputFormat;
  "std::uuid": _std.$uuid;
  "std::str": _std.$str;
  "std::pg::timestamptz": _stdpg.$timestamptz;
  "std::pg::timestamp": _stdpg.$timestamp;
  "std::pg::json": _stdpg.$json;
  "std::pg::interval": _stdpg.$interval;
  "std::pg::date": _stdpg.$date;
  "std::net::http::Method": _stdnethttp.$Method;
  "std::net::RequestState": _stdnet.$RequestState;
  "std::net::RequestFailureKind": _stdnet.$RequestFailureKind;
  "std::json": _std.$json;
  "std::int64": _std.$int64;
  "std::int32": _std.$int32;
  "std::int16": _std.$int16;
  "std::fts::document": _stdfts.$document;
  "std::fts::Weight": _stdfts.$Weight;
  "std::fts::PGLanguage": _stdfts.$PGLanguage;
  "std::fts::LuceneLanguage": _stdfts.$LuceneLanguage;
  "std::fts::Language": _stdfts.$Language;
  "std::fts::ElasticLanguage": _stdfts.$ElasticLanguage;
  "std::float64": _std.$float64;
  "std::float32": _std.$float32;
  "std::enc::Base64Alphabet": _stdenc.$Base64Alphabet;
  "std::duration": _std.$duration;
  "std::decimal": _std.$decimalλIAssignableBy;
  "std::datetime": _std.$datetime;
  "std::cal::relative_duration": _stdcal.$relative_durationλIAssignableBy;
  "std::cal::local_time": _stdcal.$local_time;
  "std::cal::local_datetime": _stdcal.$local_datetimeλIAssignableBy;
  "std::cal::local_date": _stdcal.$local_date;
  "std::cal::date_duration": _stdcal.$date_duration;
  "std::bytes": _std.$bytes;
  "std::bool": _std.$bool;
  "std::bigint": _std.$bigint;
  "std::JsonEmpty": _std.$JsonEmpty;
  "std::Endian": _std.$Endian;
  "schema::Volatility": _schema.$Volatility;
  "schema::TypeModifier": _schema.$TypeModifier;
  "schema::TriggerTiming": _schema.$TriggerTiming;
  "schema::TriggerScope": _schema.$TriggerScope;
  "schema::TriggerKind": _schema.$TriggerKind;
  "schema::TargetDeleteAction": _schema.$TargetDeleteAction;
  "schema::SourceDeleteAction": _schema.$SourceDeleteAction;
  "schema::RewriteKind": _schema.$RewriteKind;
  "schema::ParameterKind": _schema.$ParameterKind;
  "schema::OperatorKind": _schema.$OperatorKind;
  "schema::MigrationGeneratedBy": _schema.$MigrationGeneratedBy;
  "schema::IndexDeferrability": _schema.$IndexDeferrability;
  "schema::Cardinality": _schema.$Cardinality;
  "schema::AccessPolicyAction": _schema.$AccessPolicyAction;
  "schema::AccessKind": _schema.$AccessKind;
  "cfg::memory": _cfg.$memory;
  "cfg::StoreMigrationSDL": _cfg.$StoreMigrationSDL;
  "cfg::SMTPSecurity": _cfg.$SMTPSecurity;
  "cfg::QueryStatsOption": _cfg.$QueryStatsOption;
  "cfg::QueryCacheMode": _cfg.$QueryCacheMode;
  "cfg::ConnectionTransport": _cfg.$ConnectionTransport;
  "cfg::AllowBareDDL": _cfg.$AllowBareDDL;
}
export type scalarAssignableBy<T extends $.ScalarType> =
  T extends $.ScalarType<infer N extends keyof ScalarAssignableByMap>
    ? ScalarAssignableByMap[N]
    : never;

export interface ScalarCastableFromMap {
  "std::number": _std.$number;
  "sys::VersionStage": _sys.$VersionStage;
  "sys::TransactionIsolation": _sys.$TransactionIsolation;
  "sys::TransactionDeferrability": _sys.$TransactionDeferrability;
  "sys::TransactionAccessMode": _sys.$TransactionAccessMode;
  "sys::QueryType": _sys.$QueryType;
  "sys::OutputFormat": _sys.$OutputFormat;
  "std::uuid": _std.$uuid;
  "std::str": _std.$str;
  "std::pg::timestamptz": _stdpg.$timestamptz;
  "std::pg::timestamp": _stdpg.$timestamp;
  "std::pg::json": _stdpg.$json;
  "std::pg::interval": _stdpg.$interval;
  "std::pg::date": _stdpg.$date;
  "std::net::http::Method": _stdnethttp.$Method;
  "std::net::RequestState": _stdnet.$RequestState;
  "std::net::RequestFailureKind": _stdnet.$RequestFailureKind;
  "std::json": _std.$json;
  "std::int64": _std.$int64;
  "std::int32": _std.$int32;
  "std::int16": _std.$int16;
  "std::fts::document": _stdfts.$document;
  "std::fts::Weight": _stdfts.$Weight;
  "std::fts::PGLanguage": _stdfts.$PGLanguage;
  "std::fts::LuceneLanguage": _stdfts.$LuceneLanguage;
  "std::fts::Language": _stdfts.$Language;
  "std::fts::ElasticLanguage": _stdfts.$ElasticLanguage;
  "std::float64": _std.$float64;
  "std::float32": _std.$float32;
  "std::enc::Base64Alphabet": _stdenc.$Base64Alphabet;
  "std::duration": _std.$duration;
  "std::decimal": _std.$decimalλICastableTo;
  "std::datetime": _std.$datetime;
  "std::cal::relative_duration": _stdcal.$relative_durationλICastableTo;
  "std::cal::local_time": _stdcal.$local_time;
  "std::cal::local_datetime": _stdcal.$local_datetimeλICastableTo;
  "std::cal::local_date": _stdcal.$local_date;
  "std::cal::date_duration": _stdcal.$date_duration;
  "std::bytes": _std.$bytes;
  "std::bool": _std.$bool;
  "std::bigint": _std.$bigint;
  "std::JsonEmpty": _std.$JsonEmpty;
  "std::Endian": _std.$Endian;
  "schema::Volatility": _schema.$Volatility;
  "schema::TypeModifier": _schema.$TypeModifier;
  "schema::TriggerTiming": _schema.$TriggerTiming;
  "schema::TriggerScope": _schema.$TriggerScope;
  "schema::TriggerKind": _schema.$TriggerKind;
  "schema::TargetDeleteAction": _schema.$TargetDeleteAction;
  "schema::SourceDeleteAction": _schema.$SourceDeleteAction;
  "schema::RewriteKind": _schema.$RewriteKind;
  "schema::ParameterKind": _schema.$ParameterKind;
  "schema::OperatorKind": _schema.$OperatorKind;
  "schema::MigrationGeneratedBy": _schema.$MigrationGeneratedBy;
  "schema::IndexDeferrability": _schema.$IndexDeferrability;
  "schema::Cardinality": _schema.$Cardinality;
  "schema::AccessPolicyAction": _schema.$AccessPolicyAction;
  "schema::AccessKind": _schema.$AccessKind;
  "cfg::memory": _cfg.$memory;
  "cfg::StoreMigrationSDL": _cfg.$StoreMigrationSDL;
  "cfg::SMTPSecurity": _cfg.$SMTPSecurity;
  "cfg::QueryStatsOption": _cfg.$QueryStatsOption;
  "cfg::QueryCacheMode": _cfg.$QueryCacheMode;
  "cfg::ConnectionTransport": _cfg.$ConnectionTransport;
  "cfg::AllowBareDDL": _cfg.$AllowBareDDL;
}
export type scalarCastableFrom<T extends $.ScalarType> =
  T extends $.ScalarType<infer N extends keyof ScalarCastableFromMap>
    ? ScalarCastableFromMap[N]
    : never;

type getSharedParentScalar<A, B> =
  A extends $.ScalarType<infer AName>
    ? B extends $.ScalarType<infer BName>
      ? AName extends "std::decimal"
        ? BName extends "std::decimal"
          ? B
          : BName extends "std::bigint"
            ? A
            : never
        : AName extends "std::cal::relative_duration"
          ? BName extends "std::cal::relative_duration"
            ? B
            : BName extends "std::cal::date_duration"
              ? A
              : never
          : AName extends "std::cal::local_datetime"
            ? BName extends "std::cal::local_datetime"
              ? B
              : BName extends "std::cal::local_date"
                ? A
                : never
            : AName extends "std::cal::local_date"
              ? BName extends "std::cal::local_datetime"
                ? B
                : BName extends "std::cal::local_date"
                  ? B
                  : never
              : AName extends "std::cal::date_duration"
                ? BName extends "std::cal::relative_duration"
                  ? B
                  : BName extends "std::cal::date_duration"
                    ? B
                    : never
                : AName extends "std::bigint"
                  ? BName extends "std::decimal"
                    ? B
                    : BName extends "std::bigint"
                      ? B
                      : never
                  : AName extends BName
                    ? A
                    : never
      : never
    : never;

function getSharedParentScalar<A extends $.ScalarType, B extends $.ScalarType>(
  a: A,
  b: B,
): A | B {
  a = (a as any).__casttype__ || a;
  b = (b as any).__casttype__ || b;
  if (a.__name__ === "std::number") {
    if (b.__name__ === "std::number") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::VersionStage") {
    if (b.__name__ === "sys::VersionStage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::TransactionIsolation") {
    if (b.__name__ === "sys::TransactionIsolation") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::TransactionDeferrability") {
    if (b.__name__ === "sys::TransactionDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::TransactionAccessMode") {
    if (b.__name__ === "sys::TransactionAccessMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::QueryType") {
    if (b.__name__ === "sys::QueryType") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "sys::OutputFormat") {
    if (b.__name__ === "sys::OutputFormat") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::uuid") {
    if (b.__name__ === "std::uuid") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::str") {
    if (b.__name__ === "std::str") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::pg::timestamptz") {
    if (b.__name__ === "std::pg::timestamptz") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::pg::timestamp") {
    if (b.__name__ === "std::pg::timestamp") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::pg::json") {
    if (b.__name__ === "std::pg::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::pg::interval") {
    if (b.__name__ === "std::pg::interval") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::pg::date") {
    if (b.__name__ === "std::pg::date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::net::http::Method") {
    if (b.__name__ === "std::net::http::Method") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::net::RequestState") {
    if (b.__name__ === "std::net::RequestState") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::net::RequestFailureKind") {
    if (b.__name__ === "std::net::RequestFailureKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::json") {
    if (b.__name__ === "std::json") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::int64") {
    if (b.__name__ === "std::int64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::int32") {
    if (b.__name__ === "std::int32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::int16") {
    if (b.__name__ === "std::int16") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::document") {
    if (b.__name__ === "std::fts::document") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::Weight") {
    if (b.__name__ === "std::fts::Weight") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::PGLanguage") {
    if (b.__name__ === "std::fts::PGLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::LuceneLanguage") {
    if (b.__name__ === "std::fts::LuceneLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::Language") {
    if (b.__name__ === "std::fts::Language") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::fts::ElasticLanguage") {
    if (b.__name__ === "std::fts::ElasticLanguage") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::float64") {
    if (b.__name__ === "std::float64") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::float32") {
    if (b.__name__ === "std::float32") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::enc::Base64Alphabet") {
    if (b.__name__ === "std::enc::Base64Alphabet") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::duration") {
    if (b.__name__ === "std::duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::decimal") {
    if (b.__name__ === "std::decimal") {
      return b;
    }
    if (b.__name__ === "std::bigint") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::datetime") {
    if (b.__name__ === "std::datetime") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::cal::relative_duration") {
    if (b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if (b.__name__ === "std::cal::date_duration") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::cal::local_time") {
    if (b.__name__ === "std::cal::local_time") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::cal::local_datetime") {
    if (b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if (b.__name__ === "std::cal::local_date") {
      return a;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::cal::local_date") {
    if (b.__name__ === "std::cal::local_datetime") {
      return b;
    }
    if (b.__name__ === "std::cal::local_date") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::cal::date_duration") {
    if (b.__name__ === "std::cal::relative_duration") {
      return b;
    }
    if (b.__name__ === "std::cal::date_duration") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::bytes") {
    if (b.__name__ === "std::bytes") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::bool") {
    if (b.__name__ === "std::bool") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::bigint") {
    if (b.__name__ === "std::decimal") {
      return b;
    }
    if (b.__name__ === "std::bigint") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::JsonEmpty") {
    if (b.__name__ === "std::JsonEmpty") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "std::Endian") {
    if (b.__name__ === "std::Endian") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::Volatility") {
    if (b.__name__ === "schema::Volatility") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::TypeModifier") {
    if (b.__name__ === "schema::TypeModifier") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::TriggerTiming") {
    if (b.__name__ === "schema::TriggerTiming") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::TriggerScope") {
    if (b.__name__ === "schema::TriggerScope") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::TriggerKind") {
    if (b.__name__ === "schema::TriggerKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::TargetDeleteAction") {
    if (b.__name__ === "schema::TargetDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::SourceDeleteAction") {
    if (b.__name__ === "schema::SourceDeleteAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::RewriteKind") {
    if (b.__name__ === "schema::RewriteKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::ParameterKind") {
    if (b.__name__ === "schema::ParameterKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::OperatorKind") {
    if (b.__name__ === "schema::OperatorKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::MigrationGeneratedBy") {
    if (b.__name__ === "schema::MigrationGeneratedBy") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::IndexDeferrability") {
    if (b.__name__ === "schema::IndexDeferrability") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::Cardinality") {
    if (b.__name__ === "schema::Cardinality") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::AccessPolicyAction") {
    if (b.__name__ === "schema::AccessPolicyAction") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "schema::AccessKind") {
    if (b.__name__ === "schema::AccessKind") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::memory") {
    if (b.__name__ === "cfg::memory") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::StoreMigrationSDL") {
    if (b.__name__ === "cfg::StoreMigrationSDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::SMTPSecurity") {
    if (b.__name__ === "cfg::SMTPSecurity") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::QueryStatsOption") {
    if (b.__name__ === "cfg::QueryStatsOption") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::QueryCacheMode") {
    if (b.__name__ === "cfg::QueryCacheMode") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::ConnectionTransport") {
    if (b.__name__ === "cfg::ConnectionTransport") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  if (a.__name__ === "cfg::AllowBareDDL") {
    if (b.__name__ === "cfg::AllowBareDDL") {
      return b;
    }
    throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
  }
  throw new Error(`Types are not castable: ${a.__name__}, ${b.__name__}`);
}

const implicitCastMap = new Map<string, Set<string>>([
  ["std::cal::date_duration", new Set(["std::cal::relative_duration"])],
  ["std::cal::local_date", new Set(["std::cal::local_datetime"])],
  ["std::bigint", new Set(["std::decimal"])],
]);
function isImplicitlyCastableTo(from: string, to: string): boolean {
  const _a = implicitCastMap.get(from),
    _b = _a != null ? _a.has(to) : null;
  return _b != null ? _b : false;
}

export type scalarLiterals =
  | number
  | string
  | boolean
  | bigint
  | Uint8Array
  | Date
  | gel.Duration
  | gel.ConfigMemory
  | Float32Array
  | gel.LocalDateTime
  | gel.LocalDate
  | gel.LocalTime
  | gel.RelativeDuration
  | gel.DateDuration
  | gel.Range<any>
  | gel.MultiRange<any>;

type getTsType<T extends $.BaseType> = T extends $.ScalarType
  ? T extends
      | _std.$decimal
      | _stdfts.$document
      | _std.$json
      | _stdpg.$date
      | _stdpg.$interval
      | _stdpg.$json
      | _stdpg.$timestamp
      | _stdpg.$timestamptz
      | _std.$uuid
    ? never
    : T["__tstype__"]
  : T extends $.RangeType
    ? gel.Range<T["__element__"]["__tstype__"]>
    : T extends $.MultiRangeType
      ? gel.MultiRange<T["__element__"]["__tstype__"]>
      : never;
export type orScalarLiteral<T extends $.TypeSet> =
  | T
  | ($.BaseTypeSet extends T
      ? scalarLiterals
      : $.Cardinality extends T["__cardinality__"]
        ? getTsType<T["__element__"]>
        : $.computeTsTypeCard<
            getTsType<T["__element__"]>,
            T["__cardinality__"]
          >);
export type scalarWithConstType<
  T extends $.ScalarType,
  TsConstType,
> = $.ScalarType<
  T["__name__"],
  T["__tstype__"],
  T["__tsargtype__"],
  TsConstType
>;
export type literalToScalarType<T extends any> = T extends number
  ? scalarWithConstType<_std.$number, T>
  : T extends string
    ? scalarWithConstType<_std.$str, T>
    : T extends boolean
      ? scalarWithConstType<_std.$bool, T>
      : T extends bigint
        ? scalarWithConstType<_std.$bigint, T>
        : T extends Uint8Array
          ? scalarWithConstType<_std.$bytes, T>
          : T extends Date
            ? scalarWithConstType<_std.$datetime, T>
            : T extends gel.Duration
              ? scalarWithConstType<_std.$duration, T>
              : T extends gel.ConfigMemory
                ? scalarWithConstType<_cfg.$memory, T>
                : T extends gel.LocalDateTime
                  ? scalarWithConstType<_stdcal.$local_datetime, T>
                  : T extends gel.LocalDate
                    ? scalarWithConstType<_stdcal.$local_date, T>
                    : T extends gel.LocalTime
                      ? scalarWithConstType<_stdcal.$local_time, T>
                      : T extends gel.RelativeDuration
                        ? scalarWithConstType<_stdcal.$relative_duration, T>
                        : T extends gel.DateDuration
                          ? scalarWithConstType<_stdcal.$date_duration, T>
                          : T extends gel.Range<infer E>
                            ? $.RangeType<literalToScalarType<E>>
                            : T extends gel.MultiRange<infer E>
                              ? $.MultiRangeType<literalToScalarType<E>>
                              : $.BaseType;

type literalToTypeSet<T extends any> = T extends $.TypeSet
  ? T
  : $.$expr_Literal<literalToScalarType<T>>;

export type mapLiteralToTypeSet<T> = {
  [k in keyof T]: literalToTypeSet<T[k]>;
};

function literalToTypeSet(type: any): $.TypeSet {
  if (type && type.__element__) {
    return type;
  }
  if (typeof type === "number") {
    return literal.$getType("00000000-0000-0000-0000-0000000001ff")(type);
  }
  if (typeof type === "string") {
    return literal.$getType("00000000-0000-0000-0000-000000000101")(type);
  }
  if (typeof type === "boolean") {
    return literal.$getType("00000000-0000-0000-0000-000000000109")(type);
  }
  if (typeof type === "bigint") {
    return literal.$getType("00000000-0000-0000-0000-000000000110")(type);
  }
  if (type instanceof Uint8Array) {
    return literal.$getType("00000000-0000-0000-0000-000000000102")(type);
  }
  if (type instanceof Date) {
    return literal.$getType("00000000-0000-0000-0000-00000000010a")(type);
  }
  if (type instanceof gel.Duration) {
    return literal.$getType("00000000-0000-0000-0000-00000000010e")(type);
  }
  if (type instanceof gel.ConfigMemory) {
    return literal.$getType("00000000-0000-0000-0000-000000000130")(type);
  }
  if (type instanceof gel.LocalDateTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010b")(type);
  }
  if (type instanceof gel.LocalDate) {
    return literal.$getType("00000000-0000-0000-0000-00000000010c")(type);
  }
  if (type instanceof gel.LocalTime) {
    return literal.$getType("00000000-0000-0000-0000-00000000010d")(type);
  }
  if (type instanceof gel.RelativeDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000111")(type);
  }
  if (type instanceof gel.DateDuration) {
    return literal.$getType("00000000-0000-0000-0000-000000000112")(type);
  }
  throw new Error(`Cannot convert literal '${type}' into scalar type`);
}

export { getSharedParentScalar, isImplicitlyCastableTo, literalToTypeSet };
