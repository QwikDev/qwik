// GENERATED by @gel/generate v0.6.4

import * as $ from "../../reflection";
import * as _ from "../../imports";
import type * as _std from "../std";
export type $Base64Alphabet = {
  standard: $.$expr_Literal<$Base64Alphabet>;
  urlsafe: $.$expr_Literal<$Base64Alphabet>;
} & $.EnumType<"std::enc::Base64Alphabet", ["standard", "urlsafe"]>;
const Base64Alphabet: $Base64Alphabet = $.makeType<$Base64Alphabet>(
  _.spec,
  "5ca96424-93ba-560a-994b-7820c9623e3d",
  _.syntax.literal,
);

type base64_encodeλFuncExpr<
  NamedArgs extends {
    alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
    padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
> = $.$expr_Function<
  _std.$str,
  $.cardutil.multiplyCardinalities<
    $.cardutil.multiplyCardinalities<
      $.cardutil.paramCardinality<P1>,
      $.cardutil.optionalParamCardinality<NamedArgs["alphabet"]>
    >,
    $.cardutil.optionalParamCardinality<NamedArgs["padding"]>
  >
>;
type base64_encodeλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
> = $.$expr_Function<_std.$str, $.cardutil.paramCardinality<P1>>;
/**
 * Encode given data as a base64 string
 */
function base64_encode<
  NamedArgs extends {
    alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
    padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
>(namedArgs: NamedArgs, data: P1): base64_encodeλFuncExpr<NamedArgs, P1>;
/**
 * Encode given data as a base64 string
 */
function base64_encode<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>,
>(data: P1): base64_encodeλFuncExpr2<P1>;
function base64_encode(...args: any[]) {
  const {
    returnType,
    cardinality,
    args: positionalArgs,
    namedArgs,
  } = _.syntax.$resolveOverload("std::enc::base64_encode", args, _.spec, [
    {
      args: [
        {
          typeId: "00000000-0000-0000-0000-000000000102",
          optional: false,
          setoftype: false,
          variadic: false,
        },
      ],
      namedArgs: {
        alphabet: {
          typeId: "5ca96424-93ba-560a-994b-7820c9623e3d",
          optional: true,
          setoftype: false,
          variadic: false,
        },
        padding: {
          typeId: "00000000-0000-0000-0000-000000000109",
          optional: true,
          setoftype: false,
          variadic: false,
        },
      },
      returnTypeId: "00000000-0000-0000-0000-000000000101",
    },
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "std::enc::base64_encode",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
}

type base64_decodeλFuncExpr<
  NamedArgs extends {
    alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
    padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
> = $.$expr_Function<
  _std.$bytes,
  $.cardutil.multiplyCardinalities<
    $.cardutil.multiplyCardinalities<
      $.cardutil.paramCardinality<P1>,
      $.cardutil.optionalParamCardinality<NamedArgs["alphabet"]>
    >,
    $.cardutil.optionalParamCardinality<NamedArgs["padding"]>
  >
>;
type base64_decodeλFuncExpr2<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
> = $.$expr_Function<_std.$bytes, $.cardutil.paramCardinality<P1>>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
function base64_decode<
  NamedArgs extends {
    alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
    padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
  },
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
>(namedArgs: NamedArgs, data: P1): base64_decodeλFuncExpr<NamedArgs, P1>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
function base64_decode<
  P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>,
>(data: P1): base64_decodeλFuncExpr2<P1>;
function base64_decode(...args: any[]) {
  const {
    returnType,
    cardinality,
    args: positionalArgs,
    namedArgs,
  } = _.syntax.$resolveOverload("std::enc::base64_decode", args, _.spec, [
    {
      args: [
        {
          typeId: "00000000-0000-0000-0000-000000000101",
          optional: false,
          setoftype: false,
          variadic: false,
        },
      ],
      namedArgs: {
        alphabet: {
          typeId: "5ca96424-93ba-560a-994b-7820c9623e3d",
          optional: true,
          setoftype: false,
          variadic: false,
        },
        padding: {
          typeId: "00000000-0000-0000-0000-000000000109",
          optional: true,
          setoftype: false,
          variadic: false,
        },
      },
      returnTypeId: "00000000-0000-0000-0000-000000000102",
    },
  ]);
  return _.syntax.$expressionify({
    __kind__: $.ExpressionKind.Function,
    __element__: returnType,
    __cardinality__: cardinality,
    __name__: "std::enc::base64_decode",
    __args__: positionalArgs,
    __namedargs__: namedArgs,
  }) as any;
}

export { Base64Alphabet };

type __defaultExports = {
  Base64Alphabet: typeof Base64Alphabet;
  base64_encode: typeof base64_encode;
  base64_decode: typeof base64_decode;
};
const __defaultExports: __defaultExports = {
  Base64Alphabet: Base64Alphabet,
  base64_encode: base64_encode,
  base64_decode: base64_decode,
};
export default __defaultExports;
