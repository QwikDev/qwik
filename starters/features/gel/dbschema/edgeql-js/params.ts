// GENERATED by @gel/generate v0.6.4

import type { Executor } from "gel";
import {
  ExpressionKind,
  Cardinality,
  TypeKind,
} from "gel/dist/reflection/index";
import type {
  Expression,
  ParamType,
  setToTsType,
  TypeSet,
  BaseTypeToTsType,
} from "./typesystem";
import { $expressionify } from "./path";
import { runnableExpressionKinds } from "./query";
import { select } from "./select";
import { complexParamKinds } from "./__spec__";

type Param = ParamType | $expr_OptionalParam;

type ParamsRecord = Record<string, Param>;

export type $expr_OptionalParam<Type extends ParamType = ParamType> = {
  __kind__: ExpressionKind.OptionalParam;
  __type__: Type;
};

export function optional<Type extends ParamType>(
  type: Type,
): $expr_OptionalParam<Type> {
  return {
    __kind__: ExpressionKind.OptionalParam,
    __type__: type,
  };
}

export type QueryableWithParamsExpression<
  Set extends TypeSet = TypeSet,
  Params extends ParamsRecord = Record<string, never>,
> = Expression<Set, false> & {
  run(
    cxn: Executor,
    args: paramsToParamArgs<Params>,
  ): Promise<setToTsType<Set>>;
  runJSON(cxn: Executor, args: paramsToParamArgs<Params>): Promise<string>;
};

export type $expr_WithParams<
  Params extends ParamsRecord = Record<string, never>,
  Expr extends TypeSet = TypeSet,
> = QueryableWithParamsExpression<
  {
    __kind__: ExpressionKind.WithParams;
    __element__: Expr["__element__"];
    __cardinality__: Expr["__cardinality__"];
    __expr__: Expr;
    __params__: $expr_Param[];
  },
  Params
>;

type paramsToParamArgs<Params extends ParamsRecord> = {
  [key in keyof Params as Params[key] extends ParamType
    ? key
    : never]: Params[key] extends ParamType
    ? Readonly<BaseTypeToTsType<Params[key], true>>
    : never;
} & {
  [key in keyof Params as Params[key] extends $expr_OptionalParam
    ? key
    : never]?: Params[key] extends $expr_OptionalParam
    ? Readonly<BaseTypeToTsType<Params[key]["__type__"], true> | null>
    : never;
};

export type $expr_Param<
  Name extends string | number | symbol = string,
  Type extends ParamType = ParamType,
  Optional extends boolean = boolean,
> = Expression<{
  __kind__: ExpressionKind.Param;
  __element__: Type;
  __cardinality__: Optional extends true
    ? Cardinality.AtMostOne
    : Cardinality.One;
  __name__: Name;
  __isComplex__: boolean;
}>;

type paramsToParamExprs<Params extends ParamsRecord> = {
  [key in keyof Params]: Params[key] extends $expr_OptionalParam
    ? $expr_Param<key, Params[key]["__type__"], true>
    : Params[key] extends ParamType
      ? $expr_Param<key, Params[key], false>
      : never;
};

export function params<
  Params extends ParamsRecord = Record<string, never>,
  Expr extends Expression = Expression,
>(
  paramsDef: Params,
  expr: (params: paramsToParamExprs<Params>) => Expr,
): $expr_WithParams<Params, Expr> {
  const paramExprs: { [key: string]: $expr_Param } = {};
  for (const [key, param] of Object.entries(paramsDef)) {
    const paramType =
      param.__kind__ === ExpressionKind.OptionalParam ? param.__type__ : param;
    const isComplex =
      complexParamKinds.has(paramType.__kind__) ||
      (paramType.__kind__ === TypeKind.array &&
        complexParamKinds.has(paramType.__element__.__kind__));
    paramExprs[key] = $expressionify({
      __kind__: ExpressionKind.Param,
      __element__: paramType,
      __cardinality__:
        param.__kind__ === ExpressionKind.OptionalParam
          ? Cardinality.AtMostOne
          : Cardinality.One,
      __name__: key,
      __isComplex__: isComplex,
    }) as any;
  }

  let returnExpr = expr(paramExprs as any);

  if (!runnableExpressionKinds.has((returnExpr as any).__kind__)) {
    returnExpr = select(returnExpr) as any;
  }

  return $expressionify({
    __kind__: ExpressionKind.WithParams,
    __element__: returnExpr.__element__,
    __cardinality__: returnExpr.__cardinality__,
    __expr__: returnExpr,
    __params__: Object.values(paramExprs),
  }) as any;
}
